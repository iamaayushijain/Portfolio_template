{"version":3,"file":"use-lazy-load.js","sources":["../../../../components/Image/use-lazy-load.ts"],"sourcesContent":["import { useRef, useState, useEffect } from 'react';\nimport forEach from 'lodash/forEach';\nimport scrollparent from './get-scroll-parent';\n\nfunction getIntersectionObserverRoot(target: Element): Element | null {\n    const parent = scrollparent(target);\n    return parent && (parent.tagName === 'HTML' || parent.tagName === 'BODY') ? null : parent;\n}\n\nexport default function useLazyLoad(\n    el: Element | null,\n    browserSupportIntersectionObserver: boolean,\n): boolean {\n    // The total number of Intersection Observers that we end up creating. We create one for each\n    // scrollable parent element of `el`. An image within a carousel, for example, could have two\n    // scrollable parents: the carousel and the `<body>` element. We'd load the image if it is\n    // visible within the carousel and the carousel is visible within the body.\n    const [numObservers, setNumObservers] = useState<number>(0);\n    // The number of Intersection Observers we've created that have intersected.\n    const [numHaveIntersected, setNumHaveIntersected] = useState<number>(0);\n    // We store the Intersection Observer instances so that we can clean them up in the `useEffect`\n    // return function.\n    const observers = useRef<IntersectionObserver[]>([]);\n\n    useEffect(() => {\n        if (el && browserSupportIntersectionObserver) {\n            // Get array of targets and roots to use with Intersection Observer. `target` is the\n            // child element and `root` is the scrollable parent. This terminology comes from the\n            // Insersection Observer itself:\n            // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n            const observersToCreate: { target: Element; root: Element | null }[] = [];\n\n            // The first target is always the element passed in.\n            let target = el;\n            let root = getIntersectionObserverRoot(target);\n\n            observersToCreate.push({ target, root });\n\n            // If `root !== null`, that means that there is another scrollable parent. Continue\n            // traversing up the DOM tree until we get to the top.\n            while (root !== null) {\n                target = root;\n                root = getIntersectionObserverRoot(target);\n                observersToCreate.push({ target, root });\n            }\n\n            // We later use the total number of observers to determine if they are all visible.\n            setNumObservers(observersToCreate.length);\n\n            // Take the array of targets and roots and create a bunch of Intersection Observers.\n            observers.current = observersToCreate.map(p => {\n                // We disable this line since we polyfill `IntersectionObserver`.\n                // eslint-disable-next-line compat/compat\n                const observer = new IntersectionObserver(\n                    entries => {\n                        // We can assume it's the first one since we only observe one target per\n                        // IntersectionObserver.\n                        const entry = entries[0];\n\n                        // We use both `isIntersecting` and `intersectionRatio` because Edge 15\n                        // doesn't support `isIntersecting`.\n                        if (entry.isIntersecting || entry.intersectionRatio > 0) {\n                            // We need to pass in a function to `setNumHaveIntersected` so that it\n                            // can get the current value of `numHaveIntersected` within this\n                            // callback.\n                            setNumHaveIntersected(n => n + 1);\n                            // We turn off the observer once it has intersected. This is a purposely\n                            // na√Øve approach even though it introduces a small bug: images within\n                            // an auto-advancing carousel that once were `isIntersecting`\n                            // within the carousel but been auto-advanced out of view will get\n                            // loaded once the user scrolls and the carousel intersects the\n                            // `<body>`. To fix this, we'd have to increment and decrement\n                            // `observer.current`'s and then turn them all off once the image should\n                            // be loaded. This would add lot of complexity for an uncommon case so\n                            // we leave it as is.\n                            observer.unobserve(entry.target);\n                        }\n                    },\n                    {\n                        root: p.root,\n                        rootMargin: '100px',\n                    },\n                );\n\n                observer.observe(p.target);\n\n                return observer;\n            });\n        }\n\n        return function cleanObservers(): void {\n            forEach(observers.current, o => o.disconnect());\n        };\n    }, [el, browserSupportIntersectionObserver]);\n\n    // The image should load if there's at least one Intersection Observer set up and all of them\n    // have intersected. The `> 0` check prevents the hook from returning true while before it has\n    // even initialized.\n    return numObservers > 0 && numObservers === numHaveIntersected;\n}\n"],"names":["getIntersectionObserverRoot","target","parent","scrollparent","tagName","useLazyLoad","el","browserSupportIntersectionObserver","useState","numObservers","setNumObservers","numHaveIntersected","setNumHaveIntersected","observers","useRef","useEffect","observersToCreate","root","push","length","current","map","p","observer","IntersectionObserver","entries","entry","isIntersecting","intersectionRatio","n","unobserve","rootMargin","observe","cleanObservers","forEach","o","disconnect"],"mappings":";;;;;;;;;;AAIA,SAASA,2BAAT,CAAqCC,MAArC;MACUC,MAAM,GAAGC,uBAAY,CAACF,MAAD,CAA3B;SACOC,MAAM,KAAKA,MAAM,CAACE,OAAP,KAAmB,MAAnB,IAA6BF,MAAM,CAACE,OAAP,KAAmB,MAArD,CAAN,GAAqE,IAArE,GAA4EF,MAAnF;;;AAGJ,SAAwBG,YACpBC,IACAC;;;;;kBAMwCC,cAAQ,CAAS,CAAT;;MAAzCC;MAAcC;;;mBAE+BF,cAAQ,CAAS,CAAT;;MAArDG;MAAoBC;;;;MAGrBC,SAAS,GAAGC,YAAM,CAAyB,EAAzB,CAAxB;EAEAC,eAAS,CAAC;QACFT,EAAE,IAAIC,kCAAV,EAA8C;;;;;UAKpCS,iBAAiB,GAAgD,EAAvE,CAL0C;;UAQtCf,MAAM,GAAGK,EAAb;UACIW,IAAI,GAAGjB,2BAA2B,CAACC,MAAD,CAAtC;MAEAe,iBAAiB,CAACE,IAAlB,CAAuB;QAAEjB,MAAM,EAANA,MAAF;QAAUgB,IAAI,EAAJA;OAAjC,EAX0C;;;aAenCA,IAAI,KAAK,IAAhB,EAAsB;QAClBhB,MAAM,GAAGgB,IAAT;QACAA,IAAI,GAAGjB,2BAA2B,CAACC,MAAD,CAAlC;QACAe,iBAAiB,CAACE,IAAlB,CAAuB;UAAEjB,MAAM,EAANA,MAAF;UAAUgB,IAAI,EAAJA;SAAjC;OAlBsC;;;MAsB1CP,eAAe,CAACM,iBAAiB,CAACG,MAAnB,CAAf,CAtB0C;;MAyB1CN,SAAS,CAACO,OAAV,GAAoBJ,iBAAiB,CAACK,GAAlB,CAAsB,UAAAC,CAAC;;;YAGjCC,QAAQ,GAAG,IAAIC,oBAAJ,CACb,UAAAC,OAAO;;;cAGGC,KAAK,GAAGD,OAAO,CAAC,CAAD,CAArB;;;cAIIC,KAAK,CAACC,cAAN,IAAwBD,KAAK,CAACE,iBAAN,GAA0B,CAAtD,EAAyD;;;;YAIrDhB,qBAAqB,CAAC,UAAAiB,CAAC;qBAAIA,CAAC,GAAG,CAAR;aAAF,CAArB,CAJqD;;;;;;;;;;YAcrDN,QAAQ,CAACO,SAAT,CAAmBJ,KAAK,CAACzB,MAAzB;;SAtBK,EAyBb;UACIgB,IAAI,EAAEK,CAAC,CAACL,IADZ;UAEIc,UAAU,EAAE;SA3BH,CAAjB;QA+BAR,QAAQ,CAACS,OAAT,CAAiBV,CAAC,CAACrB,MAAnB;eAEOsB,QAAP;OApCgB,CAApB;;;WAwCG,SAASU,cAAT;MACHC,OAAO,CAACrB,SAAS,CAACO,OAAX,EAAoB,UAAAe,CAAC;eAAIA,CAAC,CAACC,UAAF,EAAJ;OAArB,CAAP;KADJ;GAlEK,EAqEN,CAAC9B,EAAD,EAAKC,kCAAL,CArEM,CAAT;;;;SA0EOE,YAAY,GAAG,CAAf,IAAoBA,YAAY,KAAKE,kBAA5C;;;;;"}