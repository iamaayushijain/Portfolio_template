'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.js');
var React = require('react');
var React__default = _interopDefault(React);
var forEach = _interopDefault(require('lodash/forEach'));
var getScrollParent = require('./get-scroll-parent.js');

function getIntersectionObserverRoot(target) {
  var parent = getScrollParent.default(target);
  return parent && (parent.tagName === 'HTML' || parent.tagName === 'BODY') ? null : parent;
}

function useLazyLoad(el, browserSupportIntersectionObserver) {
  // The total number of Intersection Observers that we end up creating. We create one for each
  // scrollable parent element of `el`. An image within a carousel, for example, could have two
  // scrollable parents: the carousel and the `<body>` element. We'd load the image if it is
  // visible within the carousel and the carousel is visible within the body.
  var _useState = React.useState(0),
      _useState2 = _rollupPluginBabelHelpers.slicedToArray(_useState, 2),
      numObservers = _useState2[0],
      setNumObservers = _useState2[1]; // The number of Intersection Observers we've created that have intersected.


  var _useState3 = React.useState(0),
      _useState4 = _rollupPluginBabelHelpers.slicedToArray(_useState3, 2),
      numHaveIntersected = _useState4[0],
      setNumHaveIntersected = _useState4[1]; // We store the Intersection Observer instances so that we can clean them up in the `useEffect`
  // return function.


  var observers = React.useRef([]);
  React.useEffect(function () {
    if (el && browserSupportIntersectionObserver) {
      // Get array of targets and roots to use with Intersection Observer. `target` is the
      // child element and `root` is the scrollable parent. This terminology comes from the
      // Insersection Observer itself:
      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
      var observersToCreate = []; // The first target is always the element passed in.

      var target = el;
      var root = getIntersectionObserverRoot(target);
      observersToCreate.push({
        target: target,
        root: root
      }); // If `root !== null`, that means that there is another scrollable parent. Continue
      // traversing up the DOM tree until we get to the top.

      while (root !== null) {
        target = root;
        root = getIntersectionObserverRoot(target);
        observersToCreate.push({
          target: target,
          root: root
        });
      } // We later use the total number of observers to determine if they are all visible.


      setNumObservers(observersToCreate.length); // Take the array of targets and roots and create a bunch of Intersection Observers.

      observers.current = observersToCreate.map(function (p) {
        // We disable this line since we polyfill `IntersectionObserver`.
        // eslint-disable-next-line compat/compat
        var observer = new IntersectionObserver(function (entries) {
          // We can assume it's the first one since we only observe one target per
          // IntersectionObserver.
          var entry = entries[0]; // We use both `isIntersecting` and `intersectionRatio` because Edge 15
          // doesn't support `isIntersecting`.

          if (entry.isIntersecting || entry.intersectionRatio > 0) {
            // We need to pass in a function to `setNumHaveIntersected` so that it
            // can get the current value of `numHaveIntersected` within this
            // callback.
            setNumHaveIntersected(function (n) {
              return n + 1;
            }); // We turn off the observer once it has intersected. This is a purposely
            // na√Øve approach even though it introduces a small bug: images within
            // an auto-advancing carousel that once were `isIntersecting`
            // within the carousel but been auto-advanced out of view will get
            // loaded once the user scrolls and the carousel intersects the
            // `<body>`. To fix this, we'd have to increment and decrement
            // `observer.current`'s and then turn them all off once the image should
            // be loaded. This would add lot of complexity for an uncommon case so
            // we leave it as is.

            observer.unobserve(entry.target);
          }
        }, {
          root: p.root,
          rootMargin: '100px'
        });
        observer.observe(p.target);
        return observer;
      });
    }

    return function cleanObservers() {
      forEach(observers.current, function (o) {
        return o.disconnect();
      });
    };
  }, [el, browserSupportIntersectionObserver]); // The image should load if there's at least one Intersection Observer set up and all of them
  // have intersected. The `> 0` check prevents the hook from returning true while before it has
  // even initialized.

  return numObservers > 0 && numObservers === numHaveIntersected;
}

exports.default = useLazyLoad;
//# sourceMappingURL=use-lazy-load.js.map
